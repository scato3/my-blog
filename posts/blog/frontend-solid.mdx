---
title: 프론트엔드 SOLID — 선언형 UI에 맞춘 실천과 한계
date: 2025-11-26
description: SOLID를 프론트엔드 맥락에 맞게 다시 쓰고, 적용법과 트레이드오프를 정리한다.
thumbnailUrl: /posts/thumbnail/icon-react.png
---

![](/posts/thumbnail/icon-react.png)

## 프론트엔드 SOLID — 선언형 UI에 맞춘 실천과 한계

> 프론트엔드에서 SOLID는 '객체 설계'가 아니라,  
> **변화 비용을 최소화하기 위한 UI 경계의 기술이다.**

전통적인 OOP SOLID를 프론트에 그대로 적용하면 **추상화 남용**과 **DX 악화**라는 역효과가 난다.  
선언형 UI, 상태 관리, 렌더링 파이프라인을 고려한 맞춤형 원칙이 필요하다.

---

## 1. 프론트엔드에서 SOLID가 흔히 미끄러지는 지점

> 선언형 UI에서는 객체보다 **타이밍·상태·동기화·시맨틱**이 더 중요하다.  
> 그래서 SOLID를 그대로 가져오면 대부분 어긋난다.

- UI는 입·출력만 있는 순수 함수가 아니다: 렌더링, 상호작용, 네트워크 효과가 동시에 얽힌다.
- 서버 상태(캐싱·동기화)와 클라이언트 상태(로컬 UI·폼)를 섞으면 책임이 모호해지고 캐시 전략도 꼬인다.
- 접근성/시맨틱 계약을 깨면 LSP가 무너진다. 대체 가능한 컴포넌트는 시맨틱을 유지해야 한다.
- 과한 추상화는 번들 팽창과 온보딩 비용으로 돌아온다. 프론트에서는 **필요할 때만**이 더 중요하다.

---

## 2. S — 단일 책임: 표현·상태·효과를 분리한다

> 단일 책임은 파일을 쪼개는 게 아니라,  
> **함께 바뀌는 것만 함께 두는 구조적 통찰**이다.

UI는 **보여주는 책임**에만 집중시키고, 복잡한 데이터 로직은 훅으로 분리한다.

```tsx
// Bad: 컴포넌트가 데이터 fetching, 변환, 렌더링을 모두 담당
function ProductList() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setLoading(true);
    Promise.all([
      fetch("/api/products").then((r) => r.json()),
      fetch("/api/inventory").then((r) => r.json()),
    ]).then(([products, inventory]) => {
      const available = products.filter((p) => inventory[p.id]?.stock > 0);
      setProducts(available);
      setLoading(false);
    });
  }, []);

  return loading ? <Spinner /> : <List items={products} />;
}
```

```tsx
// Good: 데이터 로직을 훅으로 분리
function useAvailableProducts() {
  const { data: products } = useQuery({
    queryKey: ["products"],
    queryFn: () => fetch("/api/products").then((r) => r.json()),
  });

  const { data: inventory } = useQuery({
    queryKey: ["inventory"],
    queryFn: () => fetch("/api/inventory").then((r) => r.json()),
  });

  return useMemo(() => {
    if (!products || !inventory) return [];
    return products.filter((p) => inventory[p.id]?.stock > 0);
  }, [products, inventory]);
}

function ProductList() {
  const products = useAvailableProducts();
  return products.length === 0 ? <Empty /> : <List items={products} />;
}
```

**SRP의 목표**는 파일 개수를 늘리는 게 아니라, 복잡한 로직을 격리해서 테스트·재사용·변경을 쉽게 만드는 것이다.

**프론트 적용**: 여러 API 조합, 데이터 변환, 복잡한 상태 관리는 훅으로 분리한다.

**한계·완화**: 단순히 useQuery를 한 번 감싸는 건 오버엔지니어링이다. 실제로 로직이 복잡하거나 재사용될 때만 분리한다.

---

## 3. O — 개방·폐쇄: 정책은 주입, 구조는 고정

> OCP는 확장을 위한 추상화가 아니라,  
> **자주 바뀌는 부분을 밖으로 밀어내고 안 바뀌는 축을 고정하는 전략**이다.

변경이 자주 일어나는 부분(스타일, 필터 조건, 렌더 로직)은 외부에서 주입받아 수정 없이 확장한다.

```tsx
// Bad: 필터 조건이 추가될 때마다 컴포넌트 수정 필요
function UserList({ users, filterType }) {
  let filtered = users;
  if (filterType === "active") {
    filtered = users.filter((u) => u.isActive);
  } else if (filterType === "admin") {
    filtered = users.filter((u) => u.role === "admin");
  } else if (filterType === "premium") {
    filtered = users.filter((u) => u.isPremium);
  }
  return <List items={filtered} />;
}
```

```tsx
// Good: 필터 함수를 주입받아 확장에 열림
function UserList({
  users,
  filterFn = (users) => users
}: {
  users: User[];
  filterFn?: (users: User[]) => User[];
}) {
  return <List items={filterFn(users)} />;
}

// 사용
<UserList users={users} filterFn={u => u.filter(x => x.isActive)} />
<UserList users={users} filterFn={u => u.filter(x => x.role === "admin")} />
```

```tsx
// Good: 스타일 변형은 토큰으로 관리
const buttonTokens = {
  primary: "bg-blue-600 text-white",
  ghost: "border border-slate-300 text-slate-700",
};

function Button({ variant = "primary", ...rest }) {
  return <button className={buttonTokens[variant]} {...rest} />;
}
```

**OCP는 분기문 금지가 아니라**, 변경 빈도가 높은 로직을 주입 가능한 경계로 만드는 것이다.

**프론트 적용**: 필터·정렬 같은 정책은 함수로, 화면 조각은 children으로, 스타일은 토큰으로 주입한다.

**한계·완화**: 모든 분기를 주입으로 바꾸면 Prop 폭발한다. 변형이 2~3개 이하면 그냥 union type으로 두고, 자주 바뀌거나 조합이 많을 때만 주입한다.

---

## 4. L — 리스코프 치환: 시맨틱과 계약을 유지한 합성

> 대체 가능성은 타입이 아니라,  
> **시맨틱·접근성·키보드 행동이라는 사용성 계약을 지켜야 성립한다.**

대체 가능한 컴포넌트는 타입 시그니처뿐 아니라 접근성·키보드·시맨틱 계약도 유지해야 한다.

```tsx
// Bad: 시맨틱/접근성 계약 위반
function FakeButton({ onClick, children }) {
  return (
    <div onClick={onClick} className="button">
      {children}
    </div>
  );
}
```

```tsx
// Good: Polymorphic 컴포넌트로 시맨틱 유지
type PolymorphicProps<E extends React.ElementType> = {
  as?: E;
  children: React.ReactNode;
} & Omit<React.ComponentPropsWithoutRef<E>, "as" | "children">;

function Action<E extends React.ElementType = "button">({
  as,
  children,
  ...props
}: PolymorphicProps<E>) {
  const Component = as || "button";
  return <Component {...props}>{children}</Component>;
}

// 사용
<Action>클릭</Action>
<Action as="a" href="/home">홈으로</Action>
```

**프론트 적용**: 컴포넌트를 교체할 때 시맨틱 HTML, ARIA 속성, 키보드 동작을 유지한다.

**한계·완화**: Polymorphic 타입은 복잡하므로, 디자인 시스템의 기본 컴포넌트(Button, Link)에만 적용하고 일반 컴포넌트는 단순하게 유지한다.

---

## 5. I — 인터페이스 분리: API 타입과 UI 계약을 필요한 만큼만 쪼갠다

> ISP는 타입 쪼개기가 아니라,  
> **UI가 실제로 필요한 만큼만 데이터 의존성을 줄이는 절제의 기술**이다.

컴포넌트가 필요하지 않은 데이터에 의존하지 않도록, Props를 최소한으로 받는다.

```tsx
// Bad: 필요 이상의 데이터에 의존
type User = {
  id: string;
  name: string;
  avatar: string;
  email: string;
  preferences: Settings;
  billing: BillingInfo;
};

function UserCard({ user }: { user: User }) {
  return (
    <div>
      <img src={user.avatar} />
      <h3>{user.name}</h3>
    </div>
  );
}
```

```tsx
// Good: 필요한 최소 props만 받음
function UserCard({ name, avatar }: { name: string; avatar: string }) {
  return (
    <div>
      <img src={avatar} />
      <h3>{name}</h3>
    </div>
  );
}
```

```tsx
// Good: 훅도 데이터 로딩과 UI 상태를 분리
function useUserProfile(userId: string) {
  return useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
  });
}

function useProfileForm() {
  const [editing, setEditing] = useState(false);
  const [draft, setDraft] = useState("");
  return { editing, setEditing, draft, setDraft };
}
```

**프론트 적용**: 컴포넌트는 필요한 최소 props만 받고, 거대한 객체는 상위에서 쪼개서 내린다. 훅도 데이터 로딩과 UI 상태를 분리한다.

**한계·완화**: 과한 세분화는 DX를 해친다. props가 3~4개 이하면 굳이 나누지 않고, 실제로 재사용되거나 테스트 격리가 필요할 때만 분리한다.

---

## 6. D — 의존성 역전: 브라우저/서버/테스트를 가르는 추상화

> 프론트의 DIP는 추상화의 철학이 아니라,  
> **브라우저·서버·테스트 환경 차이를 숨기는 실용적 안전장치**다.

환경에 따라 구현이 달라지는 효과를 인터페이스 뒤로 숨긴다.

```ts
// Bad: 플랫폼 API 직접 사용 (SSR/테스트에서 깨짐)
function saveUserPreference(key: string, value: string) {
  localStorage.setItem(key, value);
}
```

```ts
// Good: 인터페이스로 추상화
interface Storage {
  get(key: string): string | null;
  set(key: string, value: string): void;
}

export const browserStorage: Storage = {
  get: (key) => localStorage.getItem(key),
  set: (key, value) => localStorage.setItem(key, value),
};

export const memoryStorage: Storage = (() => {
  const store = new Map<string, string>();
  return {
    get: (key) => store.get(key) ?? null,
    set: (key, value) => store.set(key, value),
  };
})();

const storage = typeof window !== "undefined" ? browserStorage : memoryStorage;

function saveUserPreference(key: string, value: string, storage: Storage) {
  storage.set(key, value);
}
```

**프론트 적용**: localStorage, fetch 같은 플랫폼 API를 직접 쓰지 말고, 인터페이스로 감싸서 SSR/테스트 환경에서도 동작하게 만든다.

**한계·완화**: DI 컨테이너는 프론트에서 오버헤드가 크다. Storage, Logger 같은 소수 인터페이스만 추상화하고, 나머지는 환경 분기(typeof window)로 처리한다.

---

## 7. 한계와 트레이드오프

> SOLID의 목적은 프론트에서 "클린 코드"가 아니라,  
> **변경 비용을 최소화하는 UI 경계를 만드는 것**이다.

- **추상화 남용** → 번들/런타임 비용 상승, 온보딩 난도 증가.
- **Prop/훅 세분화** → 사용성 저하 가능. DX를 확인하며 점진적으로 분리해야 한다.
- **DIP 남용** → 프론트에서는 컨테이너/주입 코드가 오버헤드. 제품 성숙도에 맞춰 최소한으로 도입.
- **디자인 시스템 강제** → 실험 속도 둔화. 초기에는 토큰부터, 이후 컴포넌트/패턴으로 확장.

**결국 프론트엔드 SOLID는 완벽한 설계 이론이 아니라, 변화를 가장 싸고 안정적으로 흡수하기 위한 UI 전략이다.**
