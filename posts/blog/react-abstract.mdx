---
title: "리액트의 추상화는 왜 오해되고 있는가 — 함수형 철학으로 다시 보는 선언형 UI"
date: 2025-10-15
description: 리액트의 '선언형'은 진정한 추상화가 아니다. 함수형 프로그래밍의 시각에서 리액트 추상화의 본질을 해부하며, 선언형과 의미 기반 추상화의 차이를 살펴본다.
thumbnailUrl: /posts/thumbnail/icon-react.png
---

![](/posts/thumbnail/icon-react.png)

💡 <strong>리액트에서의 추상화 — 선언형 환상에서 함수형 진리로</strong>

"리액트는 선언형이다" — 하지만 선언형은 곧 추상화일까?

많은 개발자들이 이 문장에 함정처럼 빠진다.

리액트의 진정한 힘은 단지 선언형 표현이 아니라, 함수형 추상화를 통해 의미의 계층을 만드는 데 있다.

## 1. 추상화는 감추는 게 아니라, '관점을 고정하는 것'

대부분의 개발자가 추상화를 "복잡함을 숨기는 기술"로 생각한다.

하지만 함수형 프로그래밍의 세계에서 추상화란 <strong>"평가를 제한하는 것"</strong>(언제, 어떻게 실행될지 통제하는 것)이다.

즉, 코드가 오직 특정한 의미 체계 안에서만 작동하도록 만드는 일이다.

```jsx
<button onClick={() => doSomething()}>확인</button>
```

이건 단순히 브라우저의 DOM 이벤트를 잡아 처리하는 명령형 UI다.

리액트가 이를 JSX로 감쌌다고 해서 추상화된 것은 아니다.

<strong>'onClick'이라는 이벤트가 무엇을 의미하는가</strong>를 다시 정의할 때
비로소 추상화가 시작된다.

FP에서 추상화란 "구조를 감추는 것"이 아니라 <strong>"의미를 드러내는 것"</strong>이다.

## 2. 잘못된 추상화 — 선언형 안에 숨은 '명령형의 그림자'

다음 코드를 보자.

```jsx
function SearchInput({ value, onChange }) {
  return <input value={value} onChange={onChange} />;
}
```

겉보기엔 "선언형" 컴포넌트처럼 보이지만, 이건 단지 DOM 이벤트를 Props로 전달하는 위임일 뿐이다.

즉, <strong>"이 입력 필드가 무엇을 의미하는가"</strong>가 코드에 드러나지 않는다.

리액트는 선언형 UI로 "상태 → 화면"의 매핑은 잘 표현하지만,

그 행위의 의미는 여전히 개발자가 추상화해줘야 한다.

이 부분을 놓치는 순간, JSX는 다시 명령형 이벤트의 포장지로 되돌아간다.

## 3. 함수형 추상화 — "효과를 다루지 않는 구조"

리액트의 철학은 다음 한 줄에 요약된다.

```
UI = f(state)
```

이건 함수형 프로그래밍의 선언이다.

UI는 상태의 순수한 함수이며, 사이드 이펙트는 경계 밖으로 밀려나야 한다.

아래 예시는 흔한 "불완전한 추상화"의 예다.

```jsx
function SearchBox({ onSearch }) {
  const [text, setText] = useState("");

  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => onSearch(text)}>검색</button>
    </div>
  );
}
```

이 컴포넌트는 UI를 잘 조합하지만, 여전히 `onSearch`에 명령형 의존성을 남긴다.

FP적으로 해석하면 여전히 사이드 이펙트가 컴포넌트 내부에 남아있다.

이를 FP 스타일로 바꿔보자.

```jsx
function useSearch(initialQuery = "") {
  const [query, setQuery] = useState(initialQuery);
  const [results, setResults] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const search = useCallback(() => {
    // 효과는 명령(Command)으로 캡슐화되어, 호출 시점이 제어됨
    setIsLoading(true);
    return fetch(`/api/search?q=${query}`)
      .then((r) => r.json())
      .then(setResults)
      .finally(() => setIsLoading(false));
  }, [query]);

  return { query, setQuery, search, results, isLoading };
}

function SearchBox() {
  const { query, setQuery, search, results, isLoading } = useSearch();

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      <button onClick={search}>검색</button>

      {isLoading && <Spinner />}
      {results && <SearchResults data={results} />}
    </div>
  );
}
```

이제 이 구조는 <strong>UI는 순수 함수로, 효과는 캡슐화된 명령으로</strong> 분리됐다.

사이드 이펙트가 즉시 실행되지 않고 함수로 감싸져 있어, 실행 시점을 컴포넌트 외부에서 제어할 수 있다.

이건 단지 코드 리팩터링이 아니라, <strong>평가 시점을 제어하는 함수형 추상화</strong>의 구현이다.

더 나아가, React Query를 사용하면 이런 패턴을 더욱 선언적으로 만들 수 있다.

```jsx
function useSearch(query) {
  return useQuery({
    queryKey: ["search", query],
    queryFn: () => fetch(`/api/search?q=${query}`).then((r) => r.json()),
    enabled: query.length > 0, // 평가 조건을 선언적으로 제어
  });
}

function SearchBox() {
  const [query, setQuery] = useState("");
  const { data, isLoading } = useSearch(query);

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />

      {isLoading && <Spinner />}
      {data && <SearchResults data={data} />}
    </div>
  );
}
```

이제 "언제 API를 호출할지"라는 효과의 실행 조건까지 선언적으로 표현됐다.

## 4. 추상화의 척도 — 합성 가능성

FP에서 좋은 추상화는 <strong>"합성 가능한 구조"</strong>(다른 함수와 조합했을 때 의미가 유지되는 것)로 평가된다.

즉, 다른 함수와 쉽게 조합될 때 의미가 유지되어야 한다.

현대 리액트에서는 Custom Hook과 Suspense가 이를 가능하게 한다.

```jsx
function LoadingBoundary({ children }) {
  return (
    <Suspense fallback={<Spinner />}>
      <ErrorBoundary fallback={<ErrorMessage />}>{children}</ErrorBoundary>
    </Suspense>
  );
}

// 사용처에서 로딩 상태를 신경쓰지 않음
function UserProfile({ userId }) {
  const user = use(fetchUser(userId)); // React 19+ use() hook
  return <div>{user.name}</div>;
}

function App() {
  return (
    <LoadingBoundary>
      <UserProfile userId="123" />
    </LoadingBoundary>
  );
}
```

이는 단순한 재사용 패턴이 아니라, <strong>"로딩과 에러라는 개념을 경계(Boundary)로 추상화"</strong>한 것이다.

UI는 다시 하나의 합성 가능한 단위로 환원되며, 이는 FP적 사고의 정수다.

<strong>
  좋은 추상화는 재사용되는 컴포넌트가 아니라, 의미적으로 조합 가능한 함수다.
</strong>

## 5. 선언형 추상화의 철학 — 제어권의 이동

"선언형 프로그래밍"의 핵심은 <strong>제어권의 포기</strong>(내가 직접 제어하지 않고 시스템에 위임하는 것)다.

즉, "내가 데이터를 직접 조작하지 않고, 흐름을 프레임워크나 시스템에 위임하는 것"이 선언형의 본질이다.

이 원리를 리액트 추상화에 적용하면 다음과 같은 변화가 일어난다.

- <strong>상태 제어</strong>가 `useState`나 `useReducer` 같은 순수한
  인터페이스로 이동한다
- <strong>효과 제어</strong>는 `useEffect`, `useQuery`, `Suspense` 같은 외부
  경계로 밀려난다
- <strong>의미 제어</strong>는 `useAuth`, `useSearch`, `useCart`처럼 도메인
  단위로 추상화된다

즉, 선언형 추상화의 진짜 형태는 <strong>의미 중심의 제어권 재배치</strong>다.

## 6. 리액트 추상화의 3단계

함수형 구조로 본다면, 리액트의 추상화는 명확히 세 단계로 나뉜다.

<strong>1단계: 표현 추상화</strong>- JSX, Virtual DOM, 렌더링 구조 제어 - 함수형
대응: <strong>view = f(state)</strong>

<strong>2단계: 로직 추상화</strong>- 상태, 이펙트, 비즈니스 로직의 모듈화 -
함수형 대응: <strong>순수함수와 효과 함수의 분리</strong>

<strong>3단계: 의미 추상화</strong>- UI 컴포넌트를 도메인 언어로 구성 - 함수형
대응: <strong>도메인 DSL 구성</strong>

진짜 추상화는 세 번째 층에서 일어난다.

이때부터 "UI 구조"가 아니라 "업무 행위"가 코드의 최상위 개념으로 등장한다.

### 의미 추상화의 실제 예시

```jsx
//  표현 추상화 수준 (UI 중심)
function ProductCard({ product }) {
  const [cart, setCart] = useState([]);

  const handleAdd = () => {
    fetch("/api/cart", {
      method: "POST",
      body: JSON.stringify({ productId: product.id }),
    }).then(() => {
      setCart([...cart, product]);
    });
  };

  return <button onClick={handleAdd}>장바구니 추가</button>;
}

// 의미 추상화 수준 (도메인 중심)
function ProductCard({ product }) {
  const { addToCart } = useCart(); // 도메인 언어로 추상화

  return <button onClick={() => addToCart(product)}>장바구니 추가</button>;
}

// useCart는 도메인 로직을 캡슐화
function useCart() {
  const queryClient = useQueryClient();

  const addToCart = useMutation({
    mutationFn: (product) => api.cart.add(product),
    onSuccess: () => {
      queryClient.invalidateQueries(["cart"]);
      toast.success("장바구니에 추가되었습니다");
    },
  });

  return {
    addToCart: addToCart.mutate,
    isAdding: addToCart.isPending,
  };
}
```

이제 `addToCart`는 <strong>"장바구니에 추가한다"는 업무 행위</strong>를 나타내는 도메인 언어가 된다.

HTTP 요청, 상태 업데이트, 알림 표시 같은 구현 세부사항은 모두 감춰지고, 오직 <strong>의미</strong>만 남는다.

## 7. 함수형 사고로 보는 '추상화 냄새'

잘못된 추상화는 일관된 패턴을 가진다.

FP적 시각으로 보면, 이는 대부분 "부수효과가 제어되지 않은 구조"에서 나타난다.

<strong>대표적인 추상화 냄새들:</strong>

- <strong>Prop drilling everywhere</strong>: 상태가 문맥 없이 흘러내린다 →
  Context, Custom Hook으로 추상화
- <strong>Generic Component 남용</strong>: 의미 없는 범용화 → 도메인 중심
  컴포넌트로 분리
- <strong>useEffect 남용</strong>: 사이드 이펙트가 컴포넌트 안으로 침투 →
  Effect를 명령 레벨로 추출
- <strong>UI와 로직 결합</strong>: 순수성과 책임이 불명확 → View와 Behavior를
  함수로 분리

<strong>
  추상화의 목적은 복잡성을 숨기는 것이 아니라, 효과를 격리하는 것이다.
</strong>

### 구체적인 개선 예시

```jsx
// useEffect 남용 (효과가 컴포넌트 안에 침투)
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setLoading(true);
    fetch(`/api/users/${userId}`)
      .then((r) => r.json())
      .then(setUser)
      .finally(() => setLoading(false));
  }, [userId]);

  if (loading) return <Spinner />;
  return <div>{user.name}</div>;
}

// 효과를 명령 레벨로 추출
function useUser(userId) {
  return useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
  });
}

function UserProfile({ userId }) {
  const { data: user, isLoading } = useUser(userId);

  if (isLoading) return <Spinner />;
  return <div>{user.name}</div>;
}
```

이제 데이터 페칭 로직은 <strong>useUser</strong>라는 재사용 가능한 명령으로 추상화되고, 컴포넌트는 순수한 렌더링 함수로 남는다.

## 8. 궁극의 추상화 — React를 "함수 합성의 의미 공간"으로 보기

리액트 전체 트리를 함수형으로 보자면,

각 컴포넌트는 순수 함수이며,

컴포넌트 조합은 함수 합성이다.

```jsx
// 고차 함수로서의 UI
const App = compose(
  withRouting,
  withSession,
  withTheme,
  withErrorBoundary
)(Page);
```

현대적인 방식으로는 이렇게 표현된다:

```jsx
function App() {
  return (
    <Router>
      <SessionProvider>
        <ThemeProvider>
          <ErrorBoundary>
            <Page />
          </ErrorBoundary>
        </ThemeProvider>
      </SessionProvider>
    </Router>
  );
}
```

이 구조는 사실상 <strong>"고차 함수로서의 UI"</strong>를 보여준다.

Context, Provider, Boundary는 모두 함수형 합성이다.

리액트 생태계 전체가 함수형 합성의 구문 체계 안에서 돌아가는 셈이다.

### 합성의 힘: 관심사의 분리

```jsx
// 각 레이어는 독립적인 관심사를 처리
function App() {
  return (
    <Router>
      {" "}
      {/* 라우팅 관심사 */}
      <QueryProvider>
        {" "}
        {/* 데이터 관심사 */}
        <AuthProvider>
          {" "}
          {/* 인증 관심사 */}
          <ThemeProvider>
            {" "}
            {/* 스타일 관심사 */}
            <Routes />
          </ThemeProvider>
        </AuthProvider>
      </QueryProvider>
    </Router>
  );
}
```

각 Provider는 특정 관심사를 캡슐화하고, 중첩을 통해 합성된다.

이는 FP에서 말하는 "함수 합성을 통한 복잡성 관리"의 완벽한 예시다.

## 9. 실전 패턴: 도메인 중심 추상화

이론을 실전에 적용해보자. 전자상거래 장바구니 기능을 세 가지 추상화 수준으로 구현해본다.

### Level 1: 표현 추상화

```jsx
function CartButton({ productId }) {
  const [loading, setLoading] = useState(false);

  const handleClick = async () => {
    setLoading(true);
    try {
      await fetch("/api/cart", {
        method: "POST",
        body: JSON.stringify({ productId }),
      });
      alert("추가 완료!");
    } catch (error) {
      alert("실패!");
    } finally {
      setLoading(false);
    }
  };

  return (
    <button onClick={handleClick} disabled={loading}>
      {loading ? "추가 중..." : "장바구니"}
    </button>
  );
}
```

문제점: API 호출, 상태 관리, UI가 모두 뒤섞여 있다.

### Level 2: 로직 추상화

```jsx
function useAddToCart() {
  return useMutation({
    mutationFn: (productId) =>
      fetch("/api/cart", {
        method: "POST",
        body: JSON.stringify({ productId }),
      }),
    onSuccess: () => toast.success("추가 완료!"),
    onError: () => toast.error("실패!"),
  });
}

function CartButton({ productId }) {
  const { mutate, isPending } = useAddToCart();

  return (
    <button onClick={() => mutate(productId)} disabled={isPending}>
      {isPending ? "추가 중..." : "장바구니"}
    </button>
  );
}
```

개선점: 로직이 Hook으로 분리됐지만, 여전히 "추가"라는 행위에 집중한다.

### Level 3: 의미 추상화

```jsx
// 도메인 언어로 추상화
function useCart() {
  const queryClient = useQueryClient();

  const { data: cart = [] } = useQuery({
    queryKey: ["cart"],
    queryFn: () => fetch("/api/cart").then((r) => r.json()),
  });

  const addItem = useMutation({
    mutationFn: (product) => api.cart.addItem(product),
    onSuccess: () => {
      queryClient.invalidateQueries(["cart"]);
      analytics.track("cart_item_added");
      toast.success(`${product.name}이(가) 담겼습니다`);
    },
  });

  const removeItem = useMutation({
    mutationFn: (productId) => api.cart.removeItem(productId),
    onSuccess: () => {
      queryClient.invalidateQueries(["cart"]);
    },
  });

  const hasItem = (productId) => cart.some((item) => item.id === productId);

  return {
    cart,
    addItem: addItem.mutate,
    removeItem: removeItem.mutate,
    hasItem,
    isAdding: addItem.isPending,
  };
}

// 사용처: 비즈니스 의미가 명확함
function ProductCard({ product }) {
  const { addItem, hasItem, isAdding } = useCart();
  const inCart = hasItem(product.id);

  return (
    <Card>
      <h3>{product.name}</h3>
      <button onClick={() => addItem(product)} disabled={isAdding || inCart}>
        {inCart ? "담김" : "장바구니"}
      </button>
    </Card>
  );
}
```

이제 컴포넌트는 <strong>"장바구니에 담는다"</strong>는 도메인 언어로 생각한다.

HTTP, 상태 동기화, 분석 추적 같은 구현 세부사항은 모두 <strong>useCart</strong> 안에 캡슐화됐다.

## 10. 결론 — 리액트 추상화의 본질은 "의미의 함수화"

정리하자면, 이런 이야기다:

1. <strong>
     리액트의 선언형 문법은 추상화의 도구이지, 추상화 그 자체는 아니다.
   </strong>
2. <strong>
     좋은 추상화는 UI를 감싸는 게 아니라, 의도를 함수로 드러내는 것이다.
   </strong>
3. <strong>
     함수형 추상화는 부수효과를 경계 밖으로 밀어내고, 조합 가능한 의미의 층을
     만든다.
   </strong>

> <strong>
>   "리액트의 추상화란, 상태의 함수가 아닌 의미의 함수로 나아가는 여정이다."
> </strong>

선언형 UI는 출발점일 뿐이다.

리액트의 진짜 추상화는, 함수형 철학으로 '의미'를 구성하는 일이다.

추상화는 기술이 아니라 사고방식이다.

함수형 철학으로 생각하고, 의미 중심으로 설계하라.

그것이 리액트가 의도한 진정한 추상화다.
