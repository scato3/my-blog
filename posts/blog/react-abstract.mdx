---
title: "리액트의 추상화는 왜 오해되고 있는가 — 함수형 철학으로 다시 보는 선언형 UI"
date: 2025-10-15
description: 리액트의 '선언형'은 진정한 추상화가 아니다. 함수형 프로그래밍의 시각에서 리액트 추상화의 본질을 해부하며, 선언형과 의미 기반 추상화의 차이를 살펴본다.
thumbnailUrl: /posts/thumbnail/icon-react.png
---

![](/posts/thumbnail/icon-react.png)

💡 리액트에서의 추상화 — 선언형 환상에서 함수형 진리로
“리액트는 선언형이다” — 하지만 선언형은 곧 추상화일까?

많은 개발자들이 이 문장에 함정처럼 빠진다.

리액트의 진정한 힘은 단지 선언형 표현이 아니라, 함수형 추상화를 통해 의미의 계층을 만드는 데 있다.

1. 추상화는 감추는 게 아니라, '관점을 고정하는 것'
   대부분의 개발자가 추상화를 "복잡함을 숨기는 기술"로 생각한다.

하지만 함수형 프로그래밍의 세계에서 추상화란 "평가를 제한하는 것"이다.

즉, 코드가 오직 특정한 의미 체계 안에서만 작동하도록 만드는 일이다.

```jsx
<button onClick={() => doSomething()}>확인</button>
```

이건 단순히 브라우저의 DOM 이벤트를 잡아 처리하는 명령형 UI다.

리액트가 이를 JSX로 감쌌다고 해서 추상화된 것은 아니다.

‘onClick’이라는 이벤트가 무엇을 의미하는가를 다시 정의할 때 비로소 추상화가 시작된다.

FP에서 추상화란 “구조를 감추는 것”이 아니라 “의미를 드러내는 것”이다.

2. 잘못된 추상화 — 선언형 안에 숨은 ‘명령형의 그림자’
   다음 코드를 보자.

```jsx
function SearchInput({ value, onChange }) {
  return <input value={value} onChange={onChange} />;
}
```

겉보기엔 "선언형" 컴포넌트처럼 보이지만, 이건 단지 DOM 이벤트를 Props로 전달하는 위임일 뿐이다.

즉, “이 입력 필드가 무엇을 의미하는가”가 코드에 드러나지 않는다.

리액트는 선언형 UI로 “상태 → 화면”의 매핑은 잘 표현하지만,

그 행위의 의미는 여전히 개발자가 추상화해줘야 한다.

이 부분을 놓치는 순간, JSX는 다시 명령형 이벤트의 포장지로 되돌아간다.

3. 함수형 추상화 — “효과를 다루지 않는 구조”
   리액트의 철학은 다음 한 줄에 요약된다.

UI = f(state)

이건 함수형 프로그래밍의 선언이다.

UI는 상태의 순수한 함수이며, 사이드 이펙트는 경계 밖으로 밀려나야 한다.

아래 예시는 흔한 “불완전한 추상화”의 예다.

```jsx
function SearchBox({ onSearch }) {
  const [text, setText] = useState("");

  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => onSearch(text)}>검색</button>
    </div>
  );
}
```

이 컴포넌트는 UI를 잘 조합하지만, 여전히 onSearch에 명령형 의존성을 남긴다.

FP적으로 해석하면 여전히 사이드 이펙트가 컴포넌트 내부에 남아있다.

이를 FP 스타일로 바꿔보자.

```jsx
function useSearch(initial = "") {
  const [query, setQuery] = useState(initial);

  const search = useCallback(() => {
    // 효과는 함수로 감싸져 평가가 지연된다
    return fetch(`/api/search?q=${query}`).then((r) => r.json());
  }, [query]);

  return { query, setQuery, search };
}

function SearchBox() {
  const { query, setQuery, search } = useSearch();

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      <button onClick={search}>검색</button>
    </div>
  );
}
```

이제 이 구조는 UI는 순수 함수로, 효과는 평가가 지연된 함수로 분리됐다.

사이드 이펙트가 즉시 실행되지 않고 함수로 감싸져 있어, 실행 시점을 컴포넌트 외부에서 제어할 수 있다.

이건 단지 코드 리팩터링이 아니라, 평가 시점을 제어하는 함수형 추상화의 구현이다.

4. 추상화의 척도 — 합성 가능성
   FP에서 좋은 추상화는 "합성 가능한 구조"로 평가된다.

즉, 다른 함수와 쉽게 조합될 때 의미가 유지되어야 한다.

아래 고차 컴포넌트를 예로 들어보자.

```jsx
function withLoading(Component) {
  return function LoadingWrapper({ isLoading, ...props }) {
    if (isLoading) return <Spinner />;
    return <Component {...props} />;
  };
}
```

이건 단순한 재사용 패턴이 아니라, “로딩 상태라는 개념을 함수로 추상화”한 것이다.

UI는 다시 하나의 합성 가능한 단위로 환원되며, 이는 FP적 사고의 정수다.

좋은 추상화는 재사용되는 컴포넌트가 아니라, 의미적으로 조합 가능한 함수다.

5. 선언형 추상화의 철학 — 제어권의 이동
   "선언형 프로그래밍"의 핵심은 제어권의 포기다.

즉, “내가 데이터를 직접 조작하지 않고, 흐름을 프레임워크나 시스템에 위임하는 것”이 선언형의 본질이다.

이 원리를 리액트 추상화에 적용하면 다음과 같은 변화가 일어난다.

상태 제어가 useState나 useReducer 같은 순수한 인터페이스로 이동한다.
효과 제어는 useEffect, useQuery, useTransition 같은 외부 경계로 밀려난다.
의미 제어는 useAuth, useSearch, useCart처럼 도메인 단위로 추상화된다.
즉, 선언형 추상화의 진짜 형태는 의미 중심의 제어권 재배치다.

6. 리액트 추상화의 3단계
   함수형 구조로 본다면, 리액트의 추상화는 명확히 세 단계로 나뉜다.

단계 설명 함수형 대응
표현 추상화 JSX, Virtual DOM, 렌더링 구조 제어 view = f(state)
로직 추상화 상태, 이펙트, 비즈니스 로직의 모듈화 순수함수와 효과 함수의 분리
의미 추상화 UI 컴포넌트를 도메인 언어로 구성 도메인 DSL 구성
진짜 추상화는 세 번째 층에서 일어난다.

이때부터 “UI 구조”가 아니라 “업무 행위”가 코드의 최상위 개념으로 등장한다.

7. 함수형 사고로 보는 ‘추상화 냄새’
   잘못된 추상화는 일관된 패턴을 가진다.

FP적 시각으로 보면, 이는 대부분 “부수효과가 제어되지 않은 구조”에서 나타난다.

냄새 문제점 함수형 관점의 해결
Prop drilling everywhere 상태가 문맥 없이 흘러내린다 Context, Custom Hook으로 추상화
Generic Component 남용 의미 없는 범용화 도메인 중심 컴포넌트로 분리
useEffect 남용 사이드 이펙트가 컴포넌트 안으로 침투 Effect를 커맨드 레벨로 추출
UI와 로직 결합 순수성과 책임이 불명확 View와 Behavior를 함수로 분리
추상화의 목적은 복잡성을 숨기는 것이 아니라, 효과를 격리하는 것이다.

8. 궁극의 추상화 — React를 “함수 합성의 의미 공간”으로 보기
   리액트 전체 트리를 함수형으로 보자면,

각 컴포넌트는 순수 함수이며,

컴포넌트 조합은 함수 합성이다.

```jsx
const App = compose(
  withRouting,
  withSession,
  withTheme,
  withErrorBoundary
)(Page);
```

이 구조는 사실상 "고차 함수로서의 UI"를 보여준다.

HOC, Hook, Context, Provider 모두 함수형 추상화다.

리액트 생태계 전체가 함수형 합성의 구문 체계 안에서 돌아가는 셈이다.

9. 결론 — 리액트 추상화의 본질은 “의미의 함수화”
   정리하자면, 이런 이야기다:

리액트의 선언형 문법은 추상화의 도구이지, 추상화 그 자체는 아니다.
좋은 추상화는 UI를 감싸는 게 아니라, 의도를 함수로 드러내는 것이다.
함수형 추상화는 부수효과를 경계 밖으로 밀어내고,
조합 가능한 의미의 층을 만든다.
“리액트의 추상화란, 상태의 함수가 아닌 의미의 함수로 나아가는 여정이다.”

선언형 UI는 출발점일 뿐이다.

리액트의 진짜 추상화는, 함수형 철학으로 ‘의미’를 구성하는 일이다.
